<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interview Annotation Tool</title>
  <style>
    body {
      display: flex;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      gap: 20px;
    }
    #left-panel, #right-panel {
      flex: 1;
    }
    /* Container for the transcript lines */
    #text-box {
      background-color: #ffffff;
      color: black;
      padding: 20px;
      border-radius: 10px;
      min-height: 200px;
      border: 1px solid #ccc;
      margin-bottom: 20px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      overflow: hidden;
    }
    /* Individual utterance lines */
    .utterance-line {
      margin: 4px 0;
      font-size: 16px;
      line-height: 1.4;
    }
    /* Previous and next lines are grey */
    .context-line {
      color: #999;
    }
    /* Current line is darker and bold */
    .current-line {
      color: #222;
      font-weight: bold;
    }
    #top-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    #save-status {
      font-size: 14px;
    }
    .saved {
      color: green;
    }
    .unsaved {
      color: red;
    }
    #code-table {
      margin-top: 10px;
      border-collapse: collapse;
      width: 100%;
    }
    #code-table td, #code-table th {
      border: 1px solid #ddd;
      padding: 8px;
    }
    #code-table th {
      background-color: #f2f2f2;
    }
    #nav-buttons {
      margin-top: 20px;
    }
    #nav-buttons button {
      padding: 10px 20px;
      margin-right: 10px;
    }
    #new-code {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    input[type=text] {
      flex: 1;
      padding: 5px;
    }
    .error {
      color: red;
      margin-top: 5px;
    }
    /* Context textarea styles */
    #context-box {
      margin-top: 12px;
    }
    #contextLabel {
      font-weight: bold;
      margin-bottom: 4px;
      display: inline-block;
    }
    #contextInput {
      width: 100%;
      height: 120px;
      overflow-y: auto;
      overflow-x: hidden;
      resize: none;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
      background: #fff;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #contextInput:disabled {
      background: #f5f5f5;
    }
  </style>
</head>
<body>
  <div id="left-panel">
    <div id="top-buttons">
      <button onclick="saveAnnotations()">üíæ Save</button>
      <button onclick="saveCodebook()">üìò Save Codebook</button>
      <button onclick="document.getElementById('fileInput').click()">üìÅ Open</button>
      <span id="save-status" class="unsaved">‚úó Unsaved Changes</span>
      <input type="file" id="fileInput" style="display:none" />
    </div>
    <div id="text-box">Loading...</div>
    <div id="counter"></div>
    <div id="nav-buttons">
      <button onclick="prevItem()">Previous</button>
      <button onclick="nextItem()">Next</button>
    </div>
  </div>
  <div id="right-panel">
    <div><strong>New Code:</strong></div>
    <div id="new-code">
      <input type="text" id="codeInput" placeholder="Write your code here..." onkeydown="if(event.key==='Enter') addCode()" />
      <button onclick="addCode()">Add</button>
    </div>
    <div class="error" id="errorBox"></div>
    <div id="context-box">
      <div id="contextLabel">Context:</div>
      <textarea id="contextInput" placeholder="Add context for this item..."></textarea>
    </div>
    <div><strong>Existing codes:</strong></div>
    <table id="code-table">
      <tbody id="code-list"></tbody>
    </table>
  </div>
  <script>
    let config, data = [], index = 0;
    let annotations = {};
    let contexts = {};
    let codeSet = new Set();
    let originalFileName = '';
    let isSaved = false;
    let activeMergeRow = null;
    let selectedContextCode = null;

    function updateSaveStatus() {
      const status = document.getElementById('save-status');
      status.textContent = isSaved ? '‚úì All changes saved' : '‚úó Unsaved Changes';
      status.className = isSaved ? 'saved' : 'unsaved';
    }

    function loadFiles() {
      fetch('config.json')
        .then(r => r.json())
        .then(cfg => {
          config = cfg;
          originalFileName = config.dataFile;
          return fetch(config.dataFile);
        })
        .then(r => r.json())
        .then(json => {
          data = json;
          data.forEach((_, i) => {
            annotations[i] = [];
            contexts[i] = {};
          });
          render();
        });
    }

    function render() {
      const container = document.getElementById('text-box');
      container.innerHTML = '';
      if (!config || !config.mode || !config.fields || config.fields.length === 0) {
        container.innerText = '(Invalid config)';
        return;
      }
      // Display previous two, current, and next two utterances
      const start = Math.max(0, index - 2);
      const end = Math.min(data.length - 1, index + 2);
      for (let i = start; i <= end; i++) {
        const line = document.createElement('div');
        line.className = 'utterance-line';
        const text = `${data[i].Speaker}: ${data[i][config.fields[0]]}`;
        line.innerText = text;
        if (i === index) {
          line.classList.add('current-line');
        } else {
          line.classList.add('context-line');
        }
        container.appendChild(line);
      }
      updateCounter();
      renderCodeList();
      // Sync context textarea
      (function syncContextBox() {
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!ta || !label) return;
        if (selectedContextCode && annotations[index].includes(selectedContextCode)) {
          if (!contexts[index]) contexts[index] = {};
          ta.disabled = false;
          ta.value = contexts[index][selectedContextCode] || '';
          label.textContent = 'Context for "' + selectedContextCode + '":';
        } else {
          selectedContextCode = null;
          ta.disabled = true;
          ta.value = '';
          label.textContent = 'Context:';
        }
      })();
    }

    function updateCounter() {
      const total = data.length;
      const annotated = Object.values(annotations).filter(a => a.length > 0).length;
      document.getElementById('counter').innerText =
        `Seen: ${index + 1} / ${total}, Annotated: ${annotated}, Left: ${total - annotated}`;
    }

    function addCode() {
      const val = document.getElementById('codeInput').value.trim();
      if (!val) return;
      if (codeSet.has(val)) {
        showError('Code already exists.');
        return;
      }
      codeSet.add(val);
      annotations[index].push(val);
      if (!contexts[index]) contexts[index] = {};
      if (!(val in contexts[index])) contexts[index][val] = '';
      document.getElementById('codeInput').value = '';
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function showError(msg) {
      const errorBox = document.getElementById('errorBox');
      errorBox.innerText = msg;
      setTimeout(() => errorBox.innerText = '', 3000);
    }

    function editContextForCode(code) {
      selectedContextCode = code;
      const ta = document.getElementById('contextInput');
      const label = document.getElementById('contextLabel');
      if (!contexts[index]) contexts[index] = {};
      ta.disabled = false;
      ta.value = contexts[index][code] || '';
      label.textContent = 'Context for "' + code + '":';
      ta.focus();
    }

    function renderCodeList() {
      // Hierarchical view: themes -> codes -> subcodes
      const container = document.getElementById('code-list');
      container.innerHTML = '';

      // Parse all codeSet entries into a hierarchy
      function parseCodeString(raw) {
        const s = String(raw).trim();
        if (!s) return { raw: s, theme: null, code: null, sub: null };
        if (s.includes(':')) {
          const parts = s.split(':');
          const theme = parts.shift().trim();
          const rest = parts.join(':').trim();
          if (rest.includes('_')) {
            const [codePart, subPart] = rest.split('_');
            return { raw: s, theme, code: codePart.trim(), sub: subPart.trim() };
          }
          return { raw: s, theme, code: rest.trim(), sub: null };
        }
        // no colon -> theme-only
        return { raw: s, theme: s, code: null, sub: null };
      }

      // Build hierarchy map
      const hierarchy = {}; // theme -> { codes: { code -> Set(subcodes/null) }, themeOnlyExists: bool }
      Array.from(codeSet).forEach(raw => {
        const p = parseCodeString(raw);
        if (!p.theme) return;
        if (!hierarchy[p.theme]) hierarchy[p.theme] = { codes: {}, themeOnly: false };
        if (!p.code) {
          hierarchy[p.theme].themeOnly = true;
        } else {
          if (!hierarchy[p.theme].codes[p.code]) hierarchy[p.theme].codes[p.code] = new Set();
          if (p.sub) hierarchy[p.theme].codes[p.code].add(p.sub); else hierarchy[p.theme].codes[p.code].add(null);
        }
      });

      // Helpers to get raw strings under nodes and counts
      function rawStringsUnderTheme(theme) {
        const raws = [];
        Array.from(codeSet).forEach(r => { const p = parseCodeString(r); if (p.theme === theme) raws.push(r); });
        return raws;
      }
      function rawStringsUnderCode(theme, code) {
        const raws = [];
        Array.from(codeSet).forEach(r => { const p = parseCodeString(r); if (p.theme === theme && p.code === code) raws.push(r); });
        return raws;
      }

      function countRawList(list) { return list.reduce((acc, r) => acc + countCodeUse(r), 0); }

      // Render themes
      Object.keys(hierarchy).sort().forEach(theme => {
        const themeRow = document.createElement('tr');
        const tdTheme = document.createElement('td');
        tdTheme.colSpan = 7;
        const details = document.createElement('details');
        details.open = true;
        const summary = document.createElement('summary');
        summary.style.fontWeight = 'bold';
        const themeLabel = document.createElement('span');
        themeLabel.innerText = theme;
        summary.appendChild(themeLabel);

        // Theme controls
        const themeControls = document.createElement('span');
        themeControls.style.marginLeft = '12px';

        const themeCount = countRawList(rawStringsUnderTheme(theme));
        const countSpan = document.createElement('span');
        countSpan.style.marginLeft = '8px';
        countSpan.innerText = `Count: ${themeCount}`;
        themeControls.appendChild(countSpan);

        // Use checkbox for theme (creates theme-only raw if needed)
        const useChk = document.createElement('input');
        useChk.type = 'checkbox';
        const themeRaw = Array.from(codeSet).find(r => parseCodeString(r).raw === theme) || theme;
        useChk.checked = annotations[index].includes(themeRaw);
        useChk.onchange = () => {
          // ensure codeSet contains themeRaw
          if (!codeSet.has(themeRaw)) { codeSet.add(themeRaw); }
          toggleCode(themeRaw);
          renderCodeList();
        };
        themeControls.appendChild(useChk);

        const editBtn = document.createElement('button'); editBtn.innerText = 'Edit';
        editBtn.onclick = () => {
          const newTheme = prompt('Edit theme name:', theme);
          if (!newTheme || newTheme === theme) return;
          // rename all entries with this theme using helper
          const toUpdate = Array.from(codeSet).filter(r => parseCodeString(r).theme === theme);
          toUpdate.forEach(raw => {
            const p = parseCodeString(raw);
            let newRaw;
            if (!p.code) newRaw = newTheme;
            else if (!p.sub) newRaw = `${newTheme}: ${p.code}`;
            else newRaw = `${newTheme}: ${p.code}_${p.sub}`;
            renameRaw(raw, newRaw);
          });
          isSaved = false; updateSaveStatus(); renderCodeList();
        };
        themeControls.appendChild(editBtn);

        const delBtn = document.createElement('button'); delBtn.innerText = 'Delete';
        delBtn.onclick = () => {
          if (!confirm(`Delete theme "${theme}" and all its codes?`)) return;
          const toRemove = Array.from(codeSet).filter(r => parseCodeString(r).theme === theme);
          toRemove.forEach(raw => { deleteRaw(raw); });
          isSaved = false; updateSaveStatus(); renderCodeList();
        };
        themeControls.appendChild(delBtn);

        summary.appendChild(themeControls);
        details.appendChild(summary);

        // Append codes under theme
        const codes = hierarchy[theme].codes;
        Object.keys(codes).sort().forEach(code => {
          const codeDiv = document.createElement('div');
          codeDiv.style.paddingLeft = '18px';
          const codeDetails = document.createElement('details'); codeDetails.open = true;
          const codeSummary = document.createElement('summary');
          codeSummary.innerText = code;

          // code controls
          const codeControls = document.createElement('span');
          codeControls.style.marginLeft = '12px';
          const codeCount = countRawList(rawStringsUnderCode(theme, code));
          const codeCountSpan = document.createElement('span'); codeCountSpan.innerText = `Count: ${codeCount}`; codeControls.appendChild(codeCountSpan);

          const codeRaw = Array.from(codeSet).find(r => { const p = parseCodeString(r); return p.theme === theme && p.code === code && !p.sub; }) || `${theme}: ${code}`;
          const codeChk = document.createElement('input'); codeChk.type = 'checkbox'; codeChk.checked = annotations[index].includes(codeRaw);
          codeChk.onchange = () => { if (!codeSet.has(codeRaw)) codeSet.add(codeRaw); toggleCode(codeRaw); renderCodeList(); };
          codeControls.appendChild(codeChk);

          const codeEdit = document.createElement('button'); codeEdit.innerText = 'Edit';
          codeEdit.onclick = () => {
            const input = prompt(`Edit code (format: Theme:Code). Current: ${theme}:${code}`, `${theme}:${code}`);
            if (!input) return;
            const val = input.trim();
            let newTheme = theme, newCode = code;
            if (val.includes(':')) { const parts = val.split(':'); newTheme = parts.shift().trim(); newCode = parts.join(':').trim(); } else { newCode = val; }
            if (newTheme === theme && newCode === code) return;
            const toUpdate = Array.from(codeSet).filter(r => { const p = parseCodeString(r); return p.theme === theme && p.code === code; });
            toUpdate.forEach(raw => {
              const p = parseCodeString(raw);
              let newRaw; if (!p.sub) newRaw = `${newTheme}: ${newCode}`; else newRaw = `${newTheme}: ${newCode}_${p.sub}`;
              renameRaw(raw, newRaw);
            });
            isSaved = false; updateSaveStatus(); renderCodeList();
          };
          codeControls.appendChild(codeEdit);

          const codeDel = document.createElement('button'); codeDel.innerText = 'Delete';
          codeDel.onclick = () => {
            if (!confirm(`Delete code "${code}" and its subcodes?`)) return;
            const toRemove = Array.from(codeSet).filter(r => { const p = parseCodeString(r); return p.theme === theme && p.code === code; });
            toRemove.forEach(raw => { deleteRaw(raw); });
            isSaved = false; updateSaveStatus(); renderCodeList();
          };
          codeControls.appendChild(codeDel);

          codeSummary.appendChild(codeControls);
          codeDetails.appendChild(codeSummary);

          // render subcodes
          const subList = document.createElement('div'); subList.style.paddingLeft = '24px';
          const subcodes = Array.from(codes[code]).filter(x => x !== null).sort();
          subcodes.forEach(sub => {
            const subRaw = `${theme}: ${code}_${sub}`;
            const row = document.createElement('div');
            row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
            const lbl = document.createElement('div'); lbl.innerText = sub; lbl.style.minWidth = '120px';
            const cnt = document.createElement('div'); cnt.innerText = `Count: ${countCodeUse(subRaw)}`;
            const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = annotations[index].includes(subRaw); chk.onchange = () => { toggleCode(subRaw); renderCodeList(); };
            const ctxBtn = document.createElement('button'); ctxBtn.innerText = (contexts[index] && contexts[index][subRaw] && contexts[index][subRaw].length > 0) ? 'Context*' : 'Context'; ctxBtn.onclick = () => editContextForCode(subRaw); ctxBtn.disabled = !annotations[index].includes(subRaw);
            const editBtn2 = document.createElement('button'); editBtn2.innerText = 'Edit'; editBtn2.onclick = () => {
              const input = prompt(`Edit subcode (format: Theme:Code_Sub). Current: ${theme}:${code}_${sub}`, `${theme}:${code}_${sub}`);
              if (!input) return;
              const val = input.trim();
              let newTheme = theme, newCode = code, newSub = sub;
              if (val.includes(':')) { const parts = val.split(':'); newTheme = parts.shift().trim(); const rest = parts.join(':').trim(); if (rest.includes('_')) { const [c, s] = rest.split('_'); newCode = c.trim(); newSub = s.trim(); } else { newCode = rest.trim(); newSub = null; } }
              else if (val.includes('_')) { const [c, s] = val.split('_'); newCode = c.trim(); newSub = s.trim(); } else { newSub = val; }
              const newRaw = newSub ? `${newTheme}: ${newCode}_${newSub}` : `${newTheme}: ${newCode}`;
              renameRaw(subRaw, newRaw);
              isSaved = false; updateSaveStatus(); renderCodeList();
            };
            const delBtn2 = document.createElement('button'); delBtn2.innerText = 'Delete'; delBtn2.onclick = () => { if (!confirm(`Delete subcode "${sub}"?`)) return; deleteRaw(subRaw); isSaved = false; updateSaveStatus(); renderCodeList(); };
            const mergeBtn = document.createElement('button'); mergeBtn.innerText = 'Merge'; mergeBtn.onclick = () => { activeMergeRow = subRaw; renderCodeList(); };
            row.appendChild(chk); row.appendChild(lbl); row.appendChild(cnt); row.appendChild(ctxBtn); row.appendChild(editBtn2); row.appendChild(delBtn2); row.appendChild(mergeBtn);
            subList.appendChild(row);
          });

          // If activeMergeRow === some subraw under this theme, render merge UI next to this code
          if (activeMergeRow && parseCodeString(activeMergeRow).theme === theme && parseCodeString(activeMergeRow).code === code) {
            const otherSubs = subcodes.filter(s => `${theme}: ${code}_${s}` !== activeMergeRow);
            const mergeDiv = document.createElement('div'); mergeDiv.style.paddingLeft = '12px'; mergeDiv.style.marginTop = '6px';
            const select = document.createElement('select'); otherSubs.forEach(s => { const opt = document.createElement('option'); opt.value = s; opt.innerText = s; select.appendChild(opt); });
            const input = document.createElement('input'); input.type = 'text'; input.placeholder = 'New subcode name';
            const confirm = document.createElement('button'); confirm.innerText = 'Confirm'; confirm.onclick = () => {
              const selected = select.value; const newSub = input.value.trim(); if (!newSub) return alert('Enter a new name'); const src = activeMergeRow; const tgt = `${theme}: ${code}_${selected}`;
              const newRaw = `${theme}: ${code}_${newSub}`;
              // perform merge only if both subcodes belong to same theme+code
              performMerge(src, tgt, newRaw);
              activeMergeRow = null; renderCodeList();
            };
            const cancel = document.createElement('button'); cancel.innerText = 'Cancel'; cancel.onclick = () => { activeMergeRow = null; renderCodeList(); };
            mergeDiv.appendChild(select); mergeDiv.appendChild(input); mergeDiv.appendChild(confirm); mergeDiv.appendChild(cancel);
            subList.appendChild(mergeDiv);
          }

          codeDetails.appendChild(subList);
          codeDiv.appendChild(codeDetails);
          details.appendChild(codeDiv);
        });

        tdTheme.appendChild(details);
        themeRow.appendChild(tdTheme);
        container.appendChild(themeRow);
      });
    }

    function performMerge(code1, code2, newName) {
      if (!newName.trim()) return showError('You must enter a new code name.');
      if (codeSet.has(newName)) return showError('That code already exists.');
      codeSet.add(newName);
      codeSet.delete(code1);
      codeSet.delete(code2);
      Object.keys(annotations).forEach(i => {
        const set = new Set(annotations[i]);
        if (set.has(code1) || set.has(code2)) {
          set.delete(code1);
          set.delete(code2);
          set.add(newName);
          annotations[i] = Array.from(set);
          if (!contexts[i]) contexts[i] = {};
          const c1 = contexts[i][code1] || '';
          const c2 = contexts[i][code2] || '';
          if (c1 || c2) {
            const combined = (c1 && c2) ? (c1 + ' ' + c2) : (c1 || c2);
            contexts[i][newName] = combined.trim();
          }
          if (code1 in contexts[i]) delete contexts[i][code1];
          if (code2 in contexts[i]) delete contexts[i][code2];
        }
      });
      if (selectedContextCode === code1 || selectedContextCode === code2) {
        selectedContextCode = newName;
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!contexts[index]) contexts[index] = {};
        if (ta && label) {
          ta.disabled = false;
          ta.value = contexts[index][newName] || '';
          label.textContent = 'Context for "' + newName + '":';
        }
      }
      isSaved = false;
      activeMergeRow = null;
      updateSaveStatus();
      renderCodeList();
    }

    // Helper: rename/move a raw code string to newRaw across codeSet, annotations and contexts
    function renameRaw(oldRaw, newRaw) {
      if (!oldRaw || !newRaw) return;
      if (oldRaw === newRaw) return;
      const oldExists = codeSet.has(oldRaw);
      const newExists = codeSet.has(newRaw);
      if (!newExists) codeSet.add(newRaw);
      // Move usages and contexts
      Object.keys(annotations).forEach(i => {
        const list = annotations[i] || [];
        const hasOld = list.includes(oldRaw);
        if (hasOld) {
          const set = new Set(list);
          set.delete(oldRaw);
          set.add(newRaw);
          annotations[i] = Array.from(set);
        }
        if (!contexts[i]) contexts[i] = {};
        const cOld = contexts[i][oldRaw] || '';
        const cNew = contexts[i][newRaw] || '';
        if (cOld) {
          const combined = cNew ? (cNew + ' ' + cOld) : cOld;
          contexts[i][newRaw] = combined.trim();
          if (oldRaw in contexts[i]) delete contexts[i][oldRaw];
        }
      });
      // Remove old from codeSet
      if (oldExists) codeSet.delete(oldRaw);
      if (selectedContextCode === oldRaw) selectedContextCode = newRaw;
      isSaved = false; updateSaveStatus();
    }

    function deleteRaw(raw) {
      if (!raw) return;
      if (codeSet.has(raw)) codeSet.delete(raw);
      Object.keys(annotations).forEach(i => { annotations[i] = (annotations[i]||[]).filter(x => x !== raw); });
      if (typeof contexts === 'object') Object.keys(contexts).forEach(i => { if (contexts[i] && raw in contexts[i]) delete contexts[i][raw]; });
      if (selectedContextCode === raw) {
        selectedContextCode = null;
        const ta = document.getElementById('contextInput'); const label = document.getElementById('contextLabel');
        if (ta) { ta.value = ''; ta.disabled = true; }
        if (label) label.textContent = 'Context:';
      }
      isSaved = false; updateSaveStatus();
    }

    function toggleCode(code) {
      const list = annotations[index];
      const i = list.indexOf(code);
      if (i === -1) {
        list.push(code);
        if (!contexts[index]) contexts[index] = {};
        if (!(code in contexts[index])) contexts[index][code] = '';
      } else {
        list.splice(i, 1);
        if (contexts[index] && code in contexts[index]) {
          delete contexts[index][code];
          if (selectedContextCode === code) {
            const ta = document.getElementById('contextInput');
            const label = document.getElementById('contextLabel');
            selectedContextCode = null;
            if (ta) { ta.value = ''; ta.disabled = true; }
            if (label) label.textContent = 'Context:';
          }
        }
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function editCode(oldCode) {
      const newCode = prompt('Edit code:', oldCode);
      if (!newCode || newCode === oldCode) return;
      if (codeSet.has(newCode)) {
        showError('That code already exists.');
        return;
      }
      codeSet.delete(oldCode);
      codeSet.add(newCode);
      Object.keys(annotations).forEach(i => {
        annotations[i] = annotations[i].map(c => c === oldCode ? newCode : c);
      });
      Object.keys(contexts).forEach(i => {
        if (contexts[i] && oldCode in contexts[i]) {
          const val = contexts[i][oldCode];
          delete contexts[i][oldCode];
          contexts[i][newCode] = val;
        }
      });
      if (selectedContextCode === oldCode) {
        selectedContextCode = newCode;
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!contexts[index]) contexts[index] = {};
        if (ta && label) {
          ta.disabled = false;
          ta.value = contexts[index][newCode] || '';
          label.textContent = 'Context for "' + newCode + '":';
        }
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function deleteCode(code) {
      if (!confirm(`Delete code "${code}" from all entries?`)) return;
      codeSet.delete(code);
      Object.keys(annotations).forEach(i => {
        annotations[i] = annotations[i].filter(c => c !== code);
        if (contexts[i] && code in contexts[i]) {
          delete contexts[i][code];
        }
      });
      if (selectedContextCode === code) {
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        selectedContextCode = null;
        if (ta) { ta.value = ''; ta.disabled = true; }
        if (label) label.textContent = 'Context:';
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function saveAnnotations() {
      const output = data.map((item, i) => {
        const used = new Set(annotations[i] || []);
        const ctxDict = {};
        if (contexts[i]) {
          Object.keys(contexts[i]).forEach(k => {
            if (used.has(k)) ctxDict[k] = contexts[i][k];
          });
        }
        return {
          ...item,
          annotation: annotations[i],
          context: ctxDict
        };
      });
      const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'annotated_' + originalFileName;
      a.click();
      isSaved = true;
      updateSaveStatus();
    }

    function saveCodebook() {
      const codebook = Array.from(codeSet).map(code => ({
        code,
        count: countCodeUse(code)
      }));
      const blob = new Blob([JSON.stringify(codebook, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'codebook.json';
      a.click();
    }

    function countCodeUse(code) {
      return Object.values(annotations).filter(arr => arr.includes(code)).length;
    }

    function nextItem() {
      index = Math.min(index + 1, data.length - 1);
      render();
    }

    function prevItem() {
      index = Math.max(index - 1, 0);
      render();
    }

    document.getElementById('fileInput').addEventListener('change', function () {
      const reader = new FileReader();
      reader.onload = function (e) {
        const loadedData = JSON.parse(e.target.result);
        data = loadedData;
        annotations = {};
        codeSet.clear();
        contexts = {};
        data.forEach((item, i) => {
          annotations[i] = Array.isArray(item.annotation) ? item.annotation : [];
          (annotations[i] || []).forEach(code => codeSet.add(code));
          if (item && typeof item.context === 'object' && !Array.isArray(item.context)) {
            contexts[i] = { ...item.context };
          } else {
            const legacy = (typeof item.context === 'string') ? item.context : '';
            const obj = {};
            (Array.isArray(annotations[i]) ? annotations[i] : []).forEach(c => { obj[c] = legacy; });
            contexts[i] = obj;
          }
        });
        render();
      };
      reader.readAsText(this.files[0]);
    });

    document.addEventListener('DOMContentLoaded', () => {
      const ta = document.getElementById('contextInput');
      const label = document.getElementById('contextLabel');
      ta.disabled = true;
      label.textContent = 'Context:';
      ta.addEventListener('input', () => {
        if (!selectedContextCode) return;
        if (!contexts[index]) contexts[index] = {};
        contexts[index][selectedContextCode] = ta.value;
        isSaved = false;
        updateSaveStatus();
        renderCodeList();
      });
    });

    // Keyboard shortcuts: Arrow navigation + Ctrl+A / Ctrl+D
    function isTypingInForm(el) {
      if (!el) return false;
      if (el.isContentEditable) return true;
      const tag = el.tagName;
      if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
      if (el.closest && el.closest('[contenteditable="true"], [contenteditable=""]')) return true;
      return false;
    }

    document.addEventListener('keydown', function(e) {
      if (isTypingInForm(e.target)) return;
      if (e.key === 'ArrowRight' || e.key === 'ArrowDown') { e.preventDefault(); nextItem(); return; }
      if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') { e.preventDefault(); prevItem(); return; }
      if (e.ctrlKey && (e.key === 'a' || e.key === 'A')) { e.preventDefault(); prevItem(); return; }
      if (e.ctrlKey && (e.key === 'd' || e.key === 'D')) { e.preventDefault(); nextItem(); return; }
    });

    window.addEventListener('beforeunload', function (e) {
      const unsaved = Object.values(annotations).some(v => v.length === 0);
      if (!isSaved && unsaved) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    loadFiles();
  </script>
</body>
</html>