<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Open Coding Annotation Tool</title>
  <style>
    body {
      display: flex;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
      gap: 20px;
    }
    #left-panel, #right-panel {
      flex: 1;
    }
    #text-box {
      background-color: #f0f0f0;
      color: black;
      padding: 20px;
      border-radius: 10px;
      min-height: 200px;
      border: 1px solid #ccc;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    #text-box img {
      max-width: 100%;
      height: auto;
    }
    #text-box iframe {
      border: 1px solid #ccc;
      width: 375px;
      height: 667px;
      transform: scale(1);
      transform-origin: 0 0;
    }
    #top-buttons {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    #save-status {
      font-size: 14px;
    }
    .saved {
      color: green;
    }
    .unsaved {
      color: red;
    }
    #code-table {
      margin-top: 10px;
      border-collapse: collapse;
      width: 100%;
    }
    #code-table td, #code-table th {
      border: 1px solid #ddd;
      padding: 8px;
    }
    #code-table th {
      background-color: #f2f2f2;
    }
    #nav-buttons {
      margin-top: 20px;
    }
    #nav-buttons button {
      padding: 10px 20px;
      margin-right: 10px;
    }
    #new-code {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    input[type=text] {
      flex: 1;
      padding: 5px;
    }
    .error {
      color: red;
      margin-top: 5px;
    }
    /* Context textarea styles */
    #context-box { 
      margin-top: 12px; 
    }
    #contextLabel {
      font-weight: bold;
      margin-bottom: 4px;
      display: inline-block;
    }
    #contextInput {
      width: 100%;
      height: 120px;          /* fixed height */
      overflow-y: auto;       /* vertical scroll */
      overflow-x: hidden;     /* no horizontal scroll */
      resize: none;           /* keep height fixed */
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-sizing: border-box;
      background: #fff;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.4;
      white-space: pre-wrap;  /* wrap long lines */
      word-break: break-word;
    }
    #contextInput:disabled { background: #f5f5f5; }
  </style>
</head>
<body>
  <div id="left-panel">
    <div id="top-buttons">
      <button onclick="saveAnnotations()">üíæ Save</button>
      <button onclick="saveCodebook()">üìò Save Codebook</button>
      <button onclick="document.getElementById('fileInput').click()">üìÅ Open</button>
      <span id="save-status" class="unsaved">‚úó Unsaved Changes</span>
      <input type="file" id="fileInput" style="display:none" />
    </div>

    <div id="text-box">Loading...</div>
    <div id="counter"></div>
    <div id="nav-buttons">
      <button onclick="prevItem()">Previous</button>
      <button onclick="nextItem()">Next</button>
    </div>
  </div>

  <div id="right-panel">
    <div><strong>New Code:</strong></div>
    <div id="new-code">
      <input type="text" id="codeInput" placeholder="Write your code here..." onkeydown="if(event.key==='Enter') addCode()" />
      <button onclick="addCode()">Add</button>
    </div>
    <div class="error" id="errorBox"></div>
    <div id="context-box">
      <div id="contextLabel">Context:</div>
      <textarea id="contextInput" placeholder="Add context for this item..."></textarea>
    </div>
    <div><strong>Existing codes:</strong></div>
    <table id="code-table">
      <thead><tr><th>Code</th><th>Count</th><th>Use</th><th>Context</th><th>Edit</th><th>Delete</th><th>Merge</th></tr></thead>
      <tbody id="code-list"></tbody>
    </table>
  </div>

  <script>
    let config, data = [], index = 0;
    let annotations = {};
    let contexts = {}; // per-item dictionary: contexts[itemIndex][code] = string
    let codeSet = new Set();
    let originalFileName = '';
    let isSaved = false;
    let activeMergeRow = null;
    let selectedContextCode = null; // which code is active in the textarea

    function updateSaveStatus() {
      const status = document.getElementById('save-status');
      status.textContent = isSaved ? '‚úì All changes saved' : '‚úó Unsaved Changes';
      status.className = isSaved ? 'saved' : 'unsaved';
    }

    function loadFiles() {
      fetch('config.json')
        .then(r => r.json())
        .then(cfg => {
          config = cfg;
          originalFileName = config.dataFile;
          return fetch(config.dataFile);
        })
        .then(r => r.json())
        .then(json => {
          data = json;
          data.forEach((_, i) => {
            annotations[i] = [];
            contexts[i] = {}; // per-code context for each datapoint
          });
          render();
        });
    }

    function render() {
      const item = data[index];
      const container = document.getElementById('text-box');
      container.innerHTML = ''; // Clear old content
    
      if (!config || !config.mode || !config.fields || config.fields.length === 0) {
        container.innerText = '(Invalid config)';
        return;
      }
    
      const mode = config.mode;
      const field = config.fields[0];
    
      if (!(field in item)) {
        container.innerText = '(Field not found in data)';
        return;
      }
    
      if (mode === 'text') {
        container.innerText = item[field];
        container.style.justifyContent = 'flex-start';
      } else if (mode === 'image') {
        const img = document.createElement('img');
        img.src = item[field];
        img.alt = 'Image content';
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
        container.appendChild(img);
      } else if (mode === 'webpage') {
        const iframe = document.createElement('iframe');
        iframe.src = item[field];
        iframe.style.width = '100%'; // fills entire left panel
        iframe.style.height = '80vh'; // takes up vertical space nicely
        iframe.style.maxWidth = '100%';
        iframe.style.minWidth = '375px';
        iframe.style.border = '1px solid #ccc';
        iframe.style.overflow = 'auto';
        container.style.justifyContent = 'flex-start'; // left-align
        container.appendChild(iframe);
      } else {
        container.innerText = '(Unknown mode)';
      }
    
      updateCounter();
      renderCodeList();

      // Sync context textarea with current item and selection
      (function syncContextBox() {
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!ta || !label) return;
        if (selectedContextCode && annotations[index].includes(selectedContextCode)) {
          if (!contexts[index]) contexts[index] = {};
          ta.disabled = false;
          ta.value = contexts[index][selectedContextCode] || '';
          label.textContent = 'Context for "' + selectedContextCode + '":';
        } else {
          selectedContextCode = null;
          ta.disabled = true;
          ta.value = '';
          label.textContent = 'Context:';
        }
      })();
    }

    function updateCounter() {
      const total = data.length;
      const annotated = Object.values(annotations).filter(a => a.length > 0).length;
      document.getElementById('counter').innerText =
        `Seen: ${index + 1} / ${total}, Annotated: ${annotated}, Left: ${total - annotated}`;
    }

    function addCode() {
      const val = document.getElementById('codeInput').value.trim();
      if (!val) return;
      if (codeSet.has(val)) {
        showError('Code already exists.');
        return;
      }
      codeSet.add(val);
      annotations[index].push(val);
      if (!contexts[index]) contexts[index] = {};
      if (!(val in contexts[index])) contexts[index][val] = '';
      document.getElementById('codeInput').value = '';
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function showError(msg) {
      const errorBox = document.getElementById('errorBox');
      errorBox.innerText = msg;
      setTimeout(() => errorBox.innerText = '', 3000);
    }

    function editContextForCode(code) {
      selectedContextCode = code;
      const ta = document.getElementById('contextInput');
      const label = document.getElementById('contextLabel');
      if (!contexts[index]) contexts[index] = {};
      ta.disabled = false;
      ta.value = contexts[index][code] || '';
      label.textContent = 'Context for "' + code + '":';
      ta.focus();
    }

    function renderCodeList() {
      const container = document.getElementById('code-list');
      container.innerHTML = '';

      const sortedCodes = Array.from(codeSet).sort((a, b) => countCodeUse(b) - countCodeUse(a));

      sortedCodes.forEach(code => {
        const tr = document.createElement('tr');
        tr.dataset.code = code;

        const td1 = document.createElement('td');
        td1.innerText = code;

        const td2 = document.createElement('td');
        td2.innerText = countCodeUse(code);

        const td3 = document.createElement('td');
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.checked = annotations[index].includes(code);
        chk.onchange = () => toggleCode(code);
        td3.appendChild(chk);

        const tdContext = document.createElement('td');
        const ctxBtn = document.createElement('button');
        ctxBtn.innerText = (contexts[index] && contexts[index][code] && contexts[index][code].length > 0) ? 'Context*' : 'Context';
        ctxBtn.onclick = () => editContextForCode(code);
        // Enable the button only if the code is used on the current item
        ctxBtn.disabled = !annotations[index].includes(code);
        tdContext.appendChild(ctxBtn);

        const td4 = document.createElement('td');
        const editBtn = document.createElement('button');
        editBtn.innerText = 'Edit';
        editBtn.onclick = () => editCode(code);
        td4.appendChild(editBtn);

        const td5 = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.innerText = 'Delete';
        delBtn.onclick = () => deleteCode(code);
        td5.appendChild(delBtn);

        const td6 = document.createElement('td');

        if (activeMergeRow === code) {
          const otherCodes = sortedCodes.filter(c => c !== code);
          const select = document.createElement('select');
          otherCodes.forEach(c => {
            const opt = document.createElement('option');
            opt.value = c;
            opt.innerText = c;
            select.appendChild(opt);
          });

          const input = document.createElement('input');
          input.type = 'text';
          input.placeholder = 'New code name';

          const confirm = document.createElement('button');
          confirm.innerText = 'Confirm';
          confirm.onclick = () => performMerge(code, select.value, input.value);

          const cancel = document.createElement('button');
          cancel.innerText = 'Cancel';
          cancel.onclick = () => {
            activeMergeRow = null;
            renderCodeList();
          };

          td6.appendChild(select);
          td6.appendChild(document.createElement('br'));
          td6.appendChild(input);
          td6.appendChild(document.createElement('br'));
          td6.appendChild(confirm);
          td6.appendChild(cancel);
        } else {
          const mergeBtn = document.createElement('button');
          mergeBtn.innerText = 'Merge';
          mergeBtn.onclick = () => {
            activeMergeRow = code;
            renderCodeList();
          };
          td6.appendChild(mergeBtn);
        }

        [td1, td2, td3, tdContext, td4, td5, td6].forEach(td => tr.appendChild(td));
        container.appendChild(tr);
      });
    }

    function performMerge(code1, code2, newName) {
      if (!newName.trim()) return showError('You must enter a new code name.');
      if (codeSet.has(newName)) return showError('That code already exists.');

      codeSet.add(newName);
      codeSet.delete(code1);
      codeSet.delete(code2);

      Object.keys(annotations).forEach(i => {
        const set = new Set(annotations[i]);
        if (set.has(code1) || set.has(code2)) {
          set.delete(code1);
          set.delete(code2);
          set.add(newName);
          annotations[i] = Array.from(set);

          if (!contexts[i]) contexts[i] = {};
          const c1 = contexts[i][code1] || '';
          const c2 = contexts[i][code2] || '';
          if (c1 || c2) {
            const combined = (c1 && c2) ? (c1 + ' ' + c2) : (c1 || c2);
            contexts[i][newName] = combined.trim();
          }
          if (code1 in contexts[i]) delete contexts[i][code1];
          if (code2 in contexts[i]) delete contexts[i][code2];
        }
      });
      if (selectedContextCode === code1 || selectedContextCode === code2) {
        selectedContextCode = newName;
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!contexts[index]) contexts[index] = {};
        if (ta && label) {
          ta.disabled = false;
          ta.value = contexts[index][newName] || '';
          label.textContent = 'Context for "' + newName + '":';
        }
      }
      isSaved = false;
      activeMergeRow = null;
      updateSaveStatus();
      renderCodeList();
    }

    function toggleCode(code) {
      const list = annotations[index];
      const i = list.indexOf(code);
      if (i === -1) {
        list.push(code);
        if (!contexts[index]) contexts[index] = {};
        if (!(code in contexts[index])) contexts[index][code] = '';
      } else {
        list.splice(i, 1);
        if (contexts[index] && code in contexts[index]) {
          delete contexts[index][code];
          if (selectedContextCode === code) {
            const ta = document.getElementById('contextInput');
            const label = document.getElementById('contextLabel');
            selectedContextCode = null;
            if (ta) { ta.value = ''; ta.disabled = true; }
            if (label) label.textContent = 'Context:';
          }
        }
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function editCode(oldCode) {
      const newCode = prompt('Edit code:', oldCode);
      if (!newCode || newCode === oldCode) return;
      if (codeSet.has(newCode)) {
        showError('That code already exists.');
        return;
      }
      codeSet.delete(oldCode);
      codeSet.add(newCode);
      Object.keys(annotations).forEach(i => {
        annotations[i] = annotations[i].map(c => c === oldCode ? newCode : c);
      });
      Object.keys(contexts).forEach(i => {
        if (contexts[i] && oldCode in contexts[i]) {
          const val = contexts[i][oldCode];
          delete contexts[i][oldCode];
          contexts[i][newCode] = val;
        }
      });
      if (selectedContextCode === oldCode) {
        selectedContextCode = newCode;
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        if (!contexts[index]) contexts[index] = {};
        if (ta && label) {
          ta.disabled = false;
          ta.value = contexts[index][newCode] || '';
          label.textContent = 'Context for "' + newCode + '":';
        }
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function deleteCode(code) {
      if (!confirm(`Delete code "${code}" from all entries?`)) return;
      codeSet.delete(code);
      Object.keys(annotations).forEach(i => {
        annotations[i] = annotations[i].filter(c => c !== code);
        if (contexts[i] && code in contexts[i]) {
          delete contexts[i][code];
        }
      });
      if (selectedContextCode === code) {
        const ta = document.getElementById('contextInput');
        const label = document.getElementById('contextLabel');
        selectedContextCode = null;
        if (ta) { ta.value = ''; ta.disabled = true; }
        if (label) label.textContent = 'Context:';
      }
      isSaved = false;
      updateSaveStatus();
      renderCodeList();
    }

    function saveAnnotations() {
      const output = data.map((item, i) => {
        const used = new Set(annotations[i] || []);
        // keep only contexts for used codes
        const ctxDict = {};
        if (contexts[i]) {
          Object.keys(contexts[i]).forEach(k => {
            if (used.has(k)) ctxDict[k] = contexts[i][k];
          });
        }
        return {
          ...item,
          annotation: annotations[i],
          context: ctxDict
        };
      });
      const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'annotated_' + originalFileName;
      a.click();
      isSaved = true;
      updateSaveStatus();
    }

    function saveCodebook() {
      const codebook = Array.from(codeSet).map(code => ({
        code,
        count: countCodeUse(code)
      }));
      const blob = new Blob([JSON.stringify(codebook, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'codebook.json';
      a.click();
    }

    function countCodeUse(code) {
      return Object.values(annotations).filter(arr => arr.includes(code)).length;
    }

    function nextItem() {
      index = Math.min(index + 1, data.length - 1);
      render();
    }

    function prevItem() {
      index = Math.max(index - 1, 0);
      render();
    }

    document.getElementById('fileInput').addEventListener('change', function () {
      const reader = new FileReader();
      reader.onload = function (e) {
        const loadedData = JSON.parse(e.target.result);
        data = loadedData;
        annotations = {};
        codeSet.clear();
        contexts = {};
        data.forEach((item, i) => {
          annotations[i] = Array.isArray(item.annotation) ? item.annotation : [];
          (annotations[i] || []).forEach(code => codeSet.add(code));
          if (item && typeof item.context === 'object' && !Array.isArray(item.context)) {
            contexts[i] = { ...item.context };
          } else {
            // legacy string context, attach to each used code for backward compatibility
            const legacy = (typeof item.context === 'string') ? item.context : '';
            const obj = {};
            (Array.isArray(annotations[i]) ? annotations[i] : []).forEach(c => { obj[c] = legacy; });
            contexts[i] = obj;
          }
        });
        render();
      };
      reader.readAsText(this.files[0]);
    });

    // Live update of context textarea
    document.addEventListener('DOMContentLoaded', () => {
      const ta = document.getElementById('contextInput');
      const label = document.getElementById('contextLabel');
      // start disabled until a code is selected
      ta.disabled = true;
      label.textContent = 'Context:';
      ta.addEventListener('input', () => {
        if (!selectedContextCode) return;
        if (!contexts[index]) contexts[index] = {};
        contexts[index][selectedContextCode] = ta.value;
        isSaved = false;
        updateSaveStatus();
        // Refresh code list so the Context button shows the asterisk when text exists
        renderCodeList();
      });
    });

    window.addEventListener('beforeunload', function (e) {
      const unsaved = Object.values(annotations).some(v => v.length === 0);
      if (!isSaved && unsaved) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    loadFiles();
  </script>
</body>
</html>
